// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tensorflow/core/protobuf/worker.proto

package protobuf

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import tensorflow2 "github.com/tensorflow/tensorflow/tensorflow/go/core/framework"
import tensorflow13 "github.com/tensorflow/tensorflow/tensorflow/go/core/framework"
import tensorflow14 "github.com/tensorflow/tensorflow/tensorflow/go/core/framework"
import tensorflow10 "github.com/tensorflow/tensorflow/tensorflow/go/core/framework"
import tensorflow4 "github.com/tensorflow/tensorflow/tensorflow/go/core/framework"
import tensorflow_error "github.com/tensorflow/tensorflow/tensorflow/go/core/lib/core"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GetStatusRequest struct {
}

func (m *GetStatusRequest) Reset()                    { *m = GetStatusRequest{} }
func (m *GetStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*GetStatusRequest) ProtoMessage()               {}
func (*GetStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{0} }

type GetStatusResponse struct {
	DeviceAttributes []*tensorflow14.DeviceAttributes `protobuf:"bytes,1,rep,name=device_attributes,json=deviceAttributes" json:"device_attributes,omitempty"`
}

func (m *GetStatusResponse) Reset()                    { *m = GetStatusResponse{} }
func (m *GetStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*GetStatusResponse) ProtoMessage()               {}
func (*GetStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{1} }

func (m *GetStatusResponse) GetDeviceAttributes() []*tensorflow14.DeviceAttributes {
	if m != nil {
		return m.DeviceAttributes
	}
	return nil
}

type CreateWorkerSessionRequest struct {
	// Sessions are identified by a given handle.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// Defines the configuration of a TensorFlow worker.
	ServerDef *ServerDef `protobuf:"bytes,2,opt,name=server_def,json=serverDef" json:"server_def,omitempty"`
	// If true, any resources such as Variables used in the session will not be
	// shared with other sessions.
	IsolateSessionState bool `protobuf:"varint,3,opt,name=isolate_session_state,json=isolateSessionState,proto3" json:"isolate_session_state,omitempty"`
}

func (m *CreateWorkerSessionRequest) Reset()                    { *m = CreateWorkerSessionRequest{} }
func (m *CreateWorkerSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateWorkerSessionRequest) ProtoMessage()               {}
func (*CreateWorkerSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{2} }

func (m *CreateWorkerSessionRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *CreateWorkerSessionRequest) GetServerDef() *ServerDef {
	if m != nil {
		return m.ServerDef
	}
	return nil
}

func (m *CreateWorkerSessionRequest) GetIsolateSessionState() bool {
	if m != nil {
		return m.IsolateSessionState
	}
	return false
}

type CreateWorkerSessionResponse struct {
}

func (m *CreateWorkerSessionResponse) Reset()         { *m = CreateWorkerSessionResponse{} }
func (m *CreateWorkerSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CreateWorkerSessionResponse) ProtoMessage()    {}
func (*CreateWorkerSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorWorker, []int{3}
}

type DeleteWorkerSessionRequest struct {
	// Sessions are identified by a given handle.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
}

func (m *DeleteWorkerSessionRequest) Reset()                    { *m = DeleteWorkerSessionRequest{} }
func (m *DeleteWorkerSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteWorkerSessionRequest) ProtoMessage()               {}
func (*DeleteWorkerSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{4} }

func (m *DeleteWorkerSessionRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

type DeleteWorkerSessionResponse struct {
}

func (m *DeleteWorkerSessionResponse) Reset()         { *m = DeleteWorkerSessionResponse{} }
func (m *DeleteWorkerSessionResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteWorkerSessionResponse) ProtoMessage()    {}
func (*DeleteWorkerSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorWorker, []int{5}
}

type RegisterGraphRequest struct {
	// Subgraphs are scoped within one session.
	SessionHandle string `protobuf:"bytes,1,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// "graph_def" has the subgraph of nodes for this worker, with each node
	// having its device_name filled in.
	GraphDef *tensorflow10.GraphDef `protobuf:"bytes,2,opt,name=graph_def,json=graphDef" json:"graph_def,omitempty"`
	// True iff the graph (before partitioning) contains control flow nodes.
	//
	// As of 01/11/2015, this is no longer set by clients.
	HasControlFlow bool `protobuf:"varint,3,opt,name=has_control_flow,json=hasControlFlow,proto3" json:"has_control_flow,omitempty"`
	// Configuration options for the session in which this graph was created.
	GraphOptions *GraphOptions `protobuf:"bytes,4,opt,name=graph_options,json=graphOptions" json:"graph_options,omitempty"`
	// Field(s) used by TensorFlow Debugger (tfdbg).
	DebugOptions *DebugOptions `protobuf:"bytes,5,opt,name=debug_options,json=debugOptions" json:"debug_options,omitempty"`
}

func (m *RegisterGraphRequest) Reset()                    { *m = RegisterGraphRequest{} }
func (m *RegisterGraphRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterGraphRequest) ProtoMessage()               {}
func (*RegisterGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{6} }

func (m *RegisterGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RegisterGraphRequest) GetGraphDef() *tensorflow10.GraphDef {
	if m != nil {
		return m.GraphDef
	}
	return nil
}

func (m *RegisterGraphRequest) GetHasControlFlow() bool {
	if m != nil {
		return m.HasControlFlow
	}
	return false
}

func (m *RegisterGraphRequest) GetGraphOptions() *GraphOptions {
	if m != nil {
		return m.GraphOptions
	}
	return nil
}

func (m *RegisterGraphRequest) GetDebugOptions() *DebugOptions {
	if m != nil {
		return m.DebugOptions
	}
	return nil
}

type RegisterGraphResponse struct {
	// If the registration succeeds, returns an opaque graph_handle to
	// the master. The master calls RunGraph with graph_handle to
	// compute different steps.
	GraphHandle string `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
}

func (m *RegisterGraphResponse) Reset()                    { *m = RegisterGraphResponse{} }
func (m *RegisterGraphResponse) String() string            { return proto.CompactTextString(m) }
func (*RegisterGraphResponse) ProtoMessage()               {}
func (*RegisterGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{7} }

func (m *RegisterGraphResponse) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

type DeregisterGraphRequest struct {
	// The session_handle used when registering the graph. If session_handle is
	// empty, a single global namespace is used.
	SessionHandle string `protobuf:"bytes,2,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// REQUIRED: graph_handle must be returned by a RegisterGraph call
	// to the same WorkerService.
	GraphHandle string `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
}

func (m *DeregisterGraphRequest) Reset()                    { *m = DeregisterGraphRequest{} }
func (m *DeregisterGraphRequest) String() string            { return proto.CompactTextString(m) }
func (*DeregisterGraphRequest) ProtoMessage()               {}
func (*DeregisterGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{8} }

func (m *DeregisterGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *DeregisterGraphRequest) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

type DeregisterGraphResponse struct {
}

func (m *DeregisterGraphResponse) Reset()                    { *m = DeregisterGraphResponse{} }
func (m *DeregisterGraphResponse) String() string            { return proto.CompactTextString(m) }
func (*DeregisterGraphResponse) ProtoMessage()               {}
func (*DeregisterGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{9} }

type CleanupAllRequest struct {
	// A list of container names.
	//
	// If 'container' is not empty, releases resources in the given
	// containers in all devices.
	//
	// If 'container' is empty, releases resources in the default
	// container in all devices.
	Container []string `protobuf:"bytes,1,rep,name=container" json:"container,omitempty"`
}

func (m *CleanupAllRequest) Reset()                    { *m = CleanupAllRequest{} }
func (m *CleanupAllRequest) String() string            { return proto.CompactTextString(m) }
func (*CleanupAllRequest) ProtoMessage()               {}
func (*CleanupAllRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{10} }

func (m *CleanupAllRequest) GetContainer() []string {
	if m != nil {
		return m.Container
	}
	return nil
}

type CleanupAllResponse struct {
}

func (m *CleanupAllResponse) Reset()                    { *m = CleanupAllResponse{} }
func (m *CleanupAllResponse) String() string            { return proto.CompactTextString(m) }
func (*CleanupAllResponse) ProtoMessage()               {}
func (*CleanupAllResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{11} }

// Options specific to the execution of a single step.
type ExecutorOpts struct {
	RecordCosts                    bool `protobuf:"varint,1,opt,name=record_costs,json=recordCosts,proto3" json:"record_costs,omitempty"`
	RecordTimeline                 bool `protobuf:"varint,3,opt,name=record_timeline,json=recordTimeline,proto3" json:"record_timeline,omitempty"`
	RecordPartitionGraphs          bool `protobuf:"varint,4,opt,name=record_partition_graphs,json=recordPartitionGraphs,proto3" json:"record_partition_graphs,omitempty"`
	ReportTensorAllocationsUponOom bool `protobuf:"varint,5,opt,name=report_tensor_allocations_upon_oom,json=reportTensorAllocationsUponOom,proto3" json:"report_tensor_allocations_upon_oom,omitempty"`
}

func (m *ExecutorOpts) Reset()                    { *m = ExecutorOpts{} }
func (m *ExecutorOpts) String() string            { return proto.CompactTextString(m) }
func (*ExecutorOpts) ProtoMessage()               {}
func (*ExecutorOpts) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{12} }

func (m *ExecutorOpts) GetRecordCosts() bool {
	if m != nil {
		return m.RecordCosts
	}
	return false
}

func (m *ExecutorOpts) GetRecordTimeline() bool {
	if m != nil {
		return m.RecordTimeline
	}
	return false
}

func (m *ExecutorOpts) GetRecordPartitionGraphs() bool {
	if m != nil {
		return m.RecordPartitionGraphs
	}
	return false
}

func (m *ExecutorOpts) GetReportTensorAllocationsUponOom() bool {
	if m != nil {
		return m.ReportTensorAllocationsUponOom
	}
	return false
}

type RunGraphRequest struct {
	// session_handle is the master-generated unique id for this session.
	// If session_handle is non-empty, it must be the same as used when
	// registering the graph. If it is empty, a single global namespace is used to
	// search for the graph_handle.
	SessionHandle string `protobuf:"bytes,8,opt,name=session_handle,json=sessionHandle,proto3" json:"session_handle,omitempty"`
	// REQUIRED: graph_handle must be returned by a RegisterGraph call
	// to the same WorkerService.
	GraphHandle string `protobuf:"bytes,1,opt,name=graph_handle,json=graphHandle,proto3" json:"graph_handle,omitempty"`
	// A unique ID to distinguish different runs of the same graph.
	//
	// The master generates a global unique `step_id` to distinguish
	// different runs of the graph computation. Subgraphs communicate
	// (e.g., send/recv ops) with each other using `step_id` to
	// distinguish tensors generated by different runs.
	StepId int64 `protobuf:"varint,2,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	// Options for this step.
	ExecOpts *ExecutorOpts `protobuf:"bytes,5,opt,name=exec_opts,json=execOpts" json:"exec_opts,omitempty"`
	// Runs the graph.
	//
	// Sends the tensors in "send" into the graph before the run and
	// fetches the keys into `RunGraphResponse.recv` after the run.
	Send    []*NamedTensorProto `protobuf:"bytes,3,rep,name=send" json:"send,omitempty"`
	RecvKey []string            `protobuf:"bytes,4,rep,name=recv_key,json=recvKey" json:"recv_key,omitempty"`
	// True if the RunGraphRequest is a partial run request.
	IsPartial bool `protobuf:"varint,6,opt,name=is_partial,json=isPartial,proto3" json:"is_partial,omitempty"`
	// True if this is the last partial run request in a sequence of requests.
	IsLastPartialRun bool `protobuf:"varint,7,opt,name=is_last_partial_run,json=isLastPartialRun,proto3" json:"is_last_partial_run,omitempty"`
	// If true then some errors, e.g., execution errors that have long
	// error messages, may return an OK RunGraphResponse with the actual
	// error saved in the status_code/status_error_message fields of the
	// response body. This is a workaround since the RPC subsystem may
	// truncate long metadata messages.
	StoreErrorsInResponseBody bool `protobuf:"varint,9,opt,name=store_errors_in_response_body,json=storeErrorsInResponseBody,proto3" json:"store_errors_in_response_body,omitempty"`
}

func (m *RunGraphRequest) Reset()                    { *m = RunGraphRequest{} }
func (m *RunGraphRequest) String() string            { return proto.CompactTextString(m) }
func (*RunGraphRequest) ProtoMessage()               {}
func (*RunGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{13} }

func (m *RunGraphRequest) GetSessionHandle() string {
	if m != nil {
		return m.SessionHandle
	}
	return ""
}

func (m *RunGraphRequest) GetGraphHandle() string {
	if m != nil {
		return m.GraphHandle
	}
	return ""
}

func (m *RunGraphRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *RunGraphRequest) GetExecOpts() *ExecutorOpts {
	if m != nil {
		return m.ExecOpts
	}
	return nil
}

func (m *RunGraphRequest) GetSend() []*NamedTensorProto {
	if m != nil {
		return m.Send
	}
	return nil
}

func (m *RunGraphRequest) GetRecvKey() []string {
	if m != nil {
		return m.RecvKey
	}
	return nil
}

func (m *RunGraphRequest) GetIsPartial() bool {
	if m != nil {
		return m.IsPartial
	}
	return false
}

func (m *RunGraphRequest) GetIsLastPartialRun() bool {
	if m != nil {
		return m.IsLastPartialRun
	}
	return false
}

func (m *RunGraphRequest) GetStoreErrorsInResponseBody() bool {
	if m != nil {
		return m.StoreErrorsInResponseBody
	}
	return false
}

type RunGraphResponse struct {
	// A list of tensors corresponding to those requested by
	// `RunGraphRequest.recv_key`.
	Recv []*NamedTensorProto `protobuf:"bytes,1,rep,name=recv" json:"recv,omitempty"`
	// If the request asked for execution stats, the cost graph, or the partition
	// graphs, these are returned here.
	// TODO(suharshs): Package these in a RunMetadata instead.
	StepStats      *tensorflow13.StepStats   `protobuf:"bytes,2,opt,name=step_stats,json=stepStats" json:"step_stats,omitempty"`
	CostGraph      *tensorflow2.CostGraphDef `protobuf:"bytes,3,opt,name=cost_graph,json=costGraph" json:"cost_graph,omitempty"`
	PartitionGraph []*tensorflow10.GraphDef  `protobuf:"bytes,4,rep,name=partition_graph,json=partitionGraph" json:"partition_graph,omitempty"`
	// If store_errors_in_response_body is true in the request, then
	// optionally the server may return an OK status for the RPC and
	// fill the true status into the fields below, to allow for messages
	// that are too long to fit in metadata.
	StatusCode         tensorflow_error.Code `protobuf:"varint,5,opt,name=status_code,json=statusCode,proto3,enum=tensorflow.error.Code" json:"status_code,omitempty"`
	StatusErrorMessage string                `protobuf:"bytes,6,opt,name=status_error_message,json=statusErrorMessage,proto3" json:"status_error_message,omitempty"`
}

func (m *RunGraphResponse) Reset()                    { *m = RunGraphResponse{} }
func (m *RunGraphResponse) String() string            { return proto.CompactTextString(m) }
func (*RunGraphResponse) ProtoMessage()               {}
func (*RunGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{14} }

func (m *RunGraphResponse) GetRecv() []*NamedTensorProto {
	if m != nil {
		return m.Recv
	}
	return nil
}

func (m *RunGraphResponse) GetStepStats() *tensorflow13.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

func (m *RunGraphResponse) GetCostGraph() *tensorflow2.CostGraphDef {
	if m != nil {
		return m.CostGraph
	}
	return nil
}

func (m *RunGraphResponse) GetPartitionGraph() []*tensorflow10.GraphDef {
	if m != nil {
		return m.PartitionGraph
	}
	return nil
}

func (m *RunGraphResponse) GetStatusCode() tensorflow_error.Code {
	if m != nil {
		return m.StatusCode
	}
	return tensorflow_error.Code_OK
}

func (m *RunGraphResponse) GetStatusErrorMessage() string {
	if m != nil {
		return m.StatusErrorMessage
	}
	return ""
}

type CleanupGraphRequest struct {
	StepId int64 `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
}

func (m *CleanupGraphRequest) Reset()                    { *m = CleanupGraphRequest{} }
func (m *CleanupGraphRequest) String() string            { return proto.CompactTextString(m) }
func (*CleanupGraphRequest) ProtoMessage()               {}
func (*CleanupGraphRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{15} }

func (m *CleanupGraphRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

type CleanupGraphResponse struct {
}

func (m *CleanupGraphResponse) Reset()                    { *m = CleanupGraphResponse{} }
func (m *CleanupGraphResponse) String() string            { return proto.CompactTextString(m) }
func (*CleanupGraphResponse) ProtoMessage()               {}
func (*CleanupGraphResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{16} }

type RecvTensorRequest struct {
	// The step in which the tensor will be produced.
	//
	// REQUIRED: This must eventually correspond to the `step_id` passed
	// into a RunGraph call on the same WorkerService.
	StepId int64 `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	// A key identifying the channel to receive tensors from. A RecvTensor request
	// retrieves one tensor from the channel, but multiple tensors can be sent and
	// received over the same channel with multiple RecvTensor requests. See
	// rendezvous.h for details.
	RendezvousKey string `protobuf:"bytes,2,opt,name=rendezvous_key,json=rendezvousKey,proto3" json:"rendezvous_key,omitempty"`
	// If true, use an out-of-band DMA mechanism to transfer the
	// received tensor.
	DmaOk bool `protobuf:"varint,3,opt,name=dma_ok,json=dmaOk,proto3" json:"dma_ok,omitempty"`
	// Optional information on client-side device locality.
	ClientLocality *tensorflow14.DeviceLocality `protobuf:"bytes,4,opt,name=client_locality,json=clientLocality" json:"client_locality,omitempty"`
	// Optional information on server-side device locality.
	ServerLocality *tensorflow14.DeviceLocality `protobuf:"bytes,5,opt,name=server_locality,json=serverLocality" json:"server_locality,omitempty"`
	// Optional information needed by the RPC subsystem.
	TransportOptions *google_protobuf.Any `protobuf:"bytes,6,opt,name=transport_options,json=transportOptions" json:"transport_options,omitempty"`
	// Unique identifier for this request. Every RecvTensorRequest must have a
	// unique request_id, and retried RecvTensorRequests must have the same
	// request_id. If request_id is zero, retry detection is disabled.
	//
	// Retried RecvTensorRequests are problematic because a RecvTensor with no
	// corresponding sender will wait forever, and the tensor may have been
	// delivered to a previous retry. Workers use request_ids to reject retried
	// RecvTensor requests instead of waiting forever.
	RequestId int64 `protobuf:"varint,7,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *RecvTensorRequest) Reset()                    { *m = RecvTensorRequest{} }
func (m *RecvTensorRequest) String() string            { return proto.CompactTextString(m) }
func (*RecvTensorRequest) ProtoMessage()               {}
func (*RecvTensorRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{17} }

func (m *RecvTensorRequest) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *RecvTensorRequest) GetRendezvousKey() string {
	if m != nil {
		return m.RendezvousKey
	}
	return ""
}

func (m *RecvTensorRequest) GetDmaOk() bool {
	if m != nil {
		return m.DmaOk
	}
	return false
}

func (m *RecvTensorRequest) GetClientLocality() *tensorflow14.DeviceLocality {
	if m != nil {
		return m.ClientLocality
	}
	return nil
}

func (m *RecvTensorRequest) GetServerLocality() *tensorflow14.DeviceLocality {
	if m != nil {
		return m.ServerLocality
	}
	return nil
}

func (m *RecvTensorRequest) GetTransportOptions() *google_protobuf.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

func (m *RecvTensorRequest) GetRequestId() int64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

type RecvTensorResponse struct {
	// The tensor as a proto.
	Tensor *tensorflow4.TensorProto `protobuf:"bytes,1,opt,name=tensor" json:"tensor,omitempty"`
	// If true, this tensor was the output of a dead node, and the
	// content is invalid.
	IsDead bool `protobuf:"varint,2,opt,name=is_dead,json=isDead,proto3" json:"is_dead,omitempty"`
	// The time at which tensor was available and started to be returned.
	SendStartMicros int64 `protobuf:"varint,3,opt,name=send_start_micros,json=sendStartMicros,proto3" json:"send_start_micros,omitempty"`
	// Optional additional information about how to receive the tensor,
	// e.g. in the event that `RecvTensorRequest.dma_ok` was true.
	TransportOptions *google_protobuf.Any `protobuf:"bytes,4,opt,name=transport_options,json=transportOptions" json:"transport_options,omitempty"`
}

func (m *RecvTensorResponse) Reset()                    { *m = RecvTensorResponse{} }
func (m *RecvTensorResponse) String() string            { return proto.CompactTextString(m) }
func (*RecvTensorResponse) ProtoMessage()               {}
func (*RecvTensorResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{18} }

func (m *RecvTensorResponse) GetTensor() *tensorflow4.TensorProto {
	if m != nil {
		return m.Tensor
	}
	return nil
}

func (m *RecvTensorResponse) GetIsDead() bool {
	if m != nil {
		return m.IsDead
	}
	return false
}

func (m *RecvTensorResponse) GetSendStartMicros() int64 {
	if m != nil {
		return m.SendStartMicros
	}
	return 0
}

func (m *RecvTensorResponse) GetTransportOptions() *google_protobuf.Any {
	if m != nil {
		return m.TransportOptions
	}
	return nil
}

// Out-of-band request to begin or end logging, or
// to retrieve logs for particular steps.
type LoggingRequest struct {
	// If true, RPC logging will be activated.
	RpcLogging bool `protobuf:"varint,1,opt,name=rpc_logging,json=rpcLogging,proto3" json:"rpc_logging,omitempty"`
	// If true, discard any saved logging data (for all steps).
	Clear bool `protobuf:"varint,2,opt,name=clear,proto3" json:"clear,omitempty"`
	// When set, requests all saved log data pertaining to the step.
	// Any log data retrieved is eliminated from the store and cannot be
	// retrieved again.
	FetchStepId []int64 `protobuf:"varint,3,rep,packed,name=fetch_step_id,json=fetchStepId" json:"fetch_step_id,omitempty"`
}

func (m *LoggingRequest) Reset()                    { *m = LoggingRequest{} }
func (m *LoggingRequest) String() string            { return proto.CompactTextString(m) }
func (*LoggingRequest) ProtoMessage()               {}
func (*LoggingRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{19} }

func (m *LoggingRequest) GetRpcLogging() bool {
	if m != nil {
		return m.RpcLogging
	}
	return false
}

func (m *LoggingRequest) GetClear() bool {
	if m != nil {
		return m.Clear
	}
	return false
}

func (m *LoggingRequest) GetFetchStepId() []int64 {
	if m != nil {
		return m.FetchStepId
	}
	return nil
}

type LabeledStepStats struct {
	StepId    int64                   `protobuf:"varint,1,opt,name=step_id,json=stepId,proto3" json:"step_id,omitempty"`
	StepStats *tensorflow13.StepStats `protobuf:"bytes,2,opt,name=step_stats,json=stepStats" json:"step_stats,omitempty"`
}

func (m *LabeledStepStats) Reset()                    { *m = LabeledStepStats{} }
func (m *LabeledStepStats) String() string            { return proto.CompactTextString(m) }
func (*LabeledStepStats) ProtoMessage()               {}
func (*LabeledStepStats) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{20} }

func (m *LabeledStepStats) GetStepId() int64 {
	if m != nil {
		return m.StepId
	}
	return 0
}

func (m *LabeledStepStats) GetStepStats() *tensorflow13.StepStats {
	if m != nil {
		return m.StepStats
	}
	return nil
}

type LoggingResponse struct {
	Step []*LabeledStepStats `protobuf:"bytes,1,rep,name=step" json:"step,omitempty"`
}

func (m *LoggingResponse) Reset()                    { *m = LoggingResponse{} }
func (m *LoggingResponse) String() string            { return proto.CompactTextString(m) }
func (*LoggingResponse) ProtoMessage()               {}
func (*LoggingResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{21} }

func (m *LoggingResponse) GetStep() []*LabeledStepStats {
	if m != nil {
		return m.Step
	}
	return nil
}

type TraceOpts struct {
	// Length of the trace to be taken, in seconds.
	Duration float64 `protobuf:"fixed64,1,opt,name=duration,proto3" json:"duration,omitempty"`
	// If true, capture step profile locally in each worker. Currently
	// unimplemented.
	UseStepProfiler bool `protobuf:"varint,2,opt,name=use_step_profiler,json=useStepProfiler,proto3" json:"use_step_profiler,omitempty"`
	// If true, capture kernel events from each worker.
	UseKernelProfiler bool `protobuf:"varint,3,opt,name=use_kernel_profiler,json=useKernelProfiler,proto3" json:"use_kernel_profiler,omitempty"`
	// If true, capture extended profiling events from TensorFlow process.
	UseExtendedProfiler bool `protobuf:"varint,4,opt,name=use_extended_profiler,json=useExtendedProfiler,proto3" json:"use_extended_profiler,omitempty"`
	// If true, capture GPU profiling events locally on each
	// machine. Currently unimplemented.
	UseGpuProfiler bool `protobuf:"varint,5,opt,name=use_gpu_profiler,json=useGpuProfiler,proto3" json:"use_gpu_profiler,omitempty"`
	// If true, collect sampled profile events. Currently unimplemented.
	UseSampleProfiler bool `protobuf:"varint,6,opt,name=use_sample_profiler,json=useSampleProfiler,proto3" json:"use_sample_profiler,omitempty"`
}

func (m *TraceOpts) Reset()                    { *m = TraceOpts{} }
func (m *TraceOpts) String() string            { return proto.CompactTextString(m) }
func (*TraceOpts) ProtoMessage()               {}
func (*TraceOpts) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{22} }

func (m *TraceOpts) GetDuration() float64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *TraceOpts) GetUseStepProfiler() bool {
	if m != nil {
		return m.UseStepProfiler
	}
	return false
}

func (m *TraceOpts) GetUseKernelProfiler() bool {
	if m != nil {
		return m.UseKernelProfiler
	}
	return false
}

func (m *TraceOpts) GetUseExtendedProfiler() bool {
	if m != nil {
		return m.UseExtendedProfiler
	}
	return false
}

func (m *TraceOpts) GetUseGpuProfiler() bool {
	if m != nil {
		return m.UseGpuProfiler
	}
	return false
}

func (m *TraceOpts) GetUseSampleProfiler() bool {
	if m != nil {
		return m.UseSampleProfiler
	}
	return false
}

// Out-of-band request to configure distributed tracing.
type TracingRequest struct {
	Options *TraceOpts `protobuf:"bytes,1,opt,name=options" json:"options,omitempty"`
}

func (m *TracingRequest) Reset()                    { *m = TracingRequest{} }
func (m *TracingRequest) String() string            { return proto.CompactTextString(m) }
func (*TracingRequest) ProtoMessage()               {}
func (*TracingRequest) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{23} }

func (m *TracingRequest) GetOptions() *TraceOpts {
	if m != nil {
		return m.Options
	}
	return nil
}

type TracingResponse struct {
}

func (m *TracingResponse) Reset()                    { *m = TracingResponse{} }
func (m *TracingResponse) String() string            { return proto.CompactTextString(m) }
func (*TracingResponse) ProtoMessage()               {}
func (*TracingResponse) Descriptor() ([]byte, []int) { return fileDescriptorWorker, []int{24} }

func init() {
	proto.RegisterType((*GetStatusRequest)(nil), "tensorflow.GetStatusRequest")
	proto.RegisterType((*GetStatusResponse)(nil), "tensorflow.GetStatusResponse")
	proto.RegisterType((*CreateWorkerSessionRequest)(nil), "tensorflow.CreateWorkerSessionRequest")
	proto.RegisterType((*CreateWorkerSessionResponse)(nil), "tensorflow.CreateWorkerSessionResponse")
	proto.RegisterType((*DeleteWorkerSessionRequest)(nil), "tensorflow.DeleteWorkerSessionRequest")
	proto.RegisterType((*DeleteWorkerSessionResponse)(nil), "tensorflow.DeleteWorkerSessionResponse")
	proto.RegisterType((*RegisterGraphRequest)(nil), "tensorflow.RegisterGraphRequest")
	proto.RegisterType((*RegisterGraphResponse)(nil), "tensorflow.RegisterGraphResponse")
	proto.RegisterType((*DeregisterGraphRequest)(nil), "tensorflow.DeregisterGraphRequest")
	proto.RegisterType((*DeregisterGraphResponse)(nil), "tensorflow.DeregisterGraphResponse")
	proto.RegisterType((*CleanupAllRequest)(nil), "tensorflow.CleanupAllRequest")
	proto.RegisterType((*CleanupAllResponse)(nil), "tensorflow.CleanupAllResponse")
	proto.RegisterType((*ExecutorOpts)(nil), "tensorflow.ExecutorOpts")
	proto.RegisterType((*RunGraphRequest)(nil), "tensorflow.RunGraphRequest")
	proto.RegisterType((*RunGraphResponse)(nil), "tensorflow.RunGraphResponse")
	proto.RegisterType((*CleanupGraphRequest)(nil), "tensorflow.CleanupGraphRequest")
	proto.RegisterType((*CleanupGraphResponse)(nil), "tensorflow.CleanupGraphResponse")
	proto.RegisterType((*RecvTensorRequest)(nil), "tensorflow.RecvTensorRequest")
	proto.RegisterType((*RecvTensorResponse)(nil), "tensorflow.RecvTensorResponse")
	proto.RegisterType((*LoggingRequest)(nil), "tensorflow.LoggingRequest")
	proto.RegisterType((*LabeledStepStats)(nil), "tensorflow.LabeledStepStats")
	proto.RegisterType((*LoggingResponse)(nil), "tensorflow.LoggingResponse")
	proto.RegisterType((*TraceOpts)(nil), "tensorflow.TraceOpts")
	proto.RegisterType((*TracingRequest)(nil), "tensorflow.TracingRequest")
	proto.RegisterType((*TracingResponse)(nil), "tensorflow.TracingResponse")
}

func init() { proto.RegisterFile("tensorflow/core/protobuf/worker.proto", fileDescriptorWorker) }

var fileDescriptorWorker = []byte{
	// 1470 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x5f, 0x6f, 0xdb, 0x46,
	0x12, 0x07, 0xfd, 0x47, 0x96, 0x46, 0x89, 0x24, 0xd3, 0x76, 0x2c, 0xfb, 0xe2, 0x3b, 0x1f, 0x71,
	0xb9, 0x33, 0x72, 0x77, 0xb2, 0xe3, 0xbb, 0x36, 0x40, 0xd1, 0x00, 0x75, 0xe4, 0x34, 0x75, 0xe3,
	0xd4, 0xc6, 0x3a, 0x45, 0x81, 0x3e, 0x94, 0x58, 0x91, 0x23, 0x9a, 0x30, 0xc5, 0x65, 0x77, 0x97,
	0x4e, 0xdc, 0x4f, 0xd0, 0xd7, 0xbe, 0xf7, 0x2b, 0xf4, 0xa3, 0xf4, 0xb5, 0x6f, 0xed, 0xe7, 0xe8,
	0x63, 0xb1, 0x7f, 0x48, 0xd1, 0x96, 0x04, 0x27, 0xe9, 0x1b, 0x77, 0xe6, 0x37, 0xb3, 0xb3, 0xbf,
	0x99, 0x9d, 0x59, 0xc2, 0x03, 0x89, 0xa9, 0x60, 0x7c, 0x98, 0xb0, 0xd7, 0xbb, 0x01, 0xe3, 0xb8,
	0x9b, 0x71, 0x26, 0xd9, 0x20, 0x1f, 0xee, 0xbe, 0x66, 0xfc, 0x02, 0x79, 0x4f, 0xaf, 0x5d, 0x18,
	0xc3, 0x36, 0x37, 0x22, 0xc6, 0xa2, 0xa4, 0x82, 0xa4, 0xe9, 0x95, 0x81, 0x6d, 0x3e, 0xbc, 0xe9,
	0x6d, 0xc8, 0xe9, 0x08, 0x95, 0xa7, 0xdd, 0x80, 0x09, 0xe9, 0x47, 0x9c, 0x66, 0xe7, 0xb7, 0x63,
	0x85, 0xc4, 0xcc, 0x17, 0x92, 0x4a, 0x61, 0xb1, 0x8f, 0x66, 0x63, 0x43, 0xbc, 0x8c, 0x03, 0xf4,
	0xa9, 0x94, 0x3c, 0x1e, 0xe4, 0x12, 0x0b, 0x93, 0x07, 0xb3, 0x4d, 0xaa, 0x51, 0xfc, 0x73, 0x36,
	0xcc, 0x68, 0x66, 0x45, 0x9b, 0xc4, 0x03, 0xf3, 0x81, 0x9c, 0x33, 0xee, 0x07, 0x2c, 0x9c, 0xbd,
	0x75, 0xc9, 0x54, 0xc0, 0xd2, 0x61, 0x1c, 0x59, 0xd8, 0x3f, 0x66, 0xc2, 0x42, 0x1c, 0xe4, 0x05,
	0xea, 0xdf, 0x33, 0x51, 0x29, 0x1d, 0x61, 0xe8, 0x5f, 0x8b, 0x72, 0x6f, 0x26, 0x78, 0xac, 0xf0,
	0x05, 0xf2, 0xcb, 0x22, 0xb1, 0x9e, 0x0b, 0x9d, 0xe7, 0x28, 0xcf, 0x24, 0x95, 0xb9, 0x20, 0xf8,
	0x6d, 0x8e, 0x42, 0x7a, 0xdf, 0xc0, 0x72, 0x45, 0x26, 0x32, 0x96, 0x0a, 0x74, 0x8f, 0x60, 0x79,
	0x82, 0xea, 0xae, 0xb3, 0x3d, 0xbf, 0xd3, 0xdc, 0xbf, 0xdf, 0x1b, 0x7b, 0xef, 0x1d, 0x6a, 0xd0,
	0x41, 0x89, 0x21, 0x9d, 0xf0, 0x86, 0xc4, 0xfb, 0xc9, 0x81, 0xcd, 0x3e, 0x47, 0x2a, 0xf1, 0x2b,
	0x5d, 0x63, 0x67, 0x28, 0x44, 0xcc, 0x52, 0xbb, 0xbd, 0xfb, 0x00, 0x5a, 0xc2, 0x48, 0xfc, 0x73,
	0x9a, 0x86, 0x09, 0x76, 0x9d, 0x6d, 0x67, 0xa7, 0x41, 0xee, 0x5a, 0xe9, 0x67, 0x5a, 0xe8, 0xfe,
	0x1f, 0xc0, 0x9c, 0xc4, 0x0f, 0x71, 0xd8, 0x9d, 0xdb, 0x76, 0x76, 0x9a, 0xfb, 0x6b, 0xd5, 0x48,
	0xce, 0xb4, 0xf6, 0x10, 0x87, 0xa4, 0x21, 0x8a, 0x4f, 0x77, 0x1f, 0xd6, 0x62, 0xc1, 0x12, 0x2a,
	0xd1, 0x2f, 0x36, 0x51, 0x85, 0x86, 0xdd, 0xf9, 0x6d, 0x67, 0xa7, 0x4e, 0x56, 0xac, 0xd2, 0x86,
	0xa4, 0x38, 0x40, 0x6f, 0x0b, 0xfe, 0x32, 0x35, 0x5c, 0xc3, 0x8c, 0xd7, 0x87, 0xcd, 0x43, 0x4c,
	0xf0, 0x4f, 0x9d, 0x46, 0xed, 0x31, 0xd5, 0x89, 0xdd, 0xe3, 0xc7, 0x39, 0x58, 0x25, 0x18, 0xc5,
	0x42, 0x22, 0x7f, 0xae, 0xca, 0xf7, 0x1d, 0xc9, 0x7a, 0x04, 0x0d, 0x5d, 0xf5, 0x15, 0xae, 0x56,
	0xab, 0x5c, 0x69, 0x9f, 0x8a, 0xaa, 0x7a, 0x64, 0xbf, 0xdc, 0xff, 0x40, 0xe7, 0x9c, 0x0a, 0x3f,
	0x60, 0xa9, 0xe4, 0x2c, 0xf1, 0x15, 0xcc, 0x90, 0xf4, 0x74, 0xae, 0xeb, 0x90, 0xd6, 0x39, 0x15,
	0x7d, 0xa3, 0xfa, 0x34, 0x61, 0xaf, 0xdd, 0x27, 0x70, 0xd7, 0x6c, 0xc0, 0x32, 0x19, 0xb3, 0x54,
	0x74, 0x17, 0xf4, 0x26, 0xdd, 0x89, 0x4d, 0x4e, 0x8c, 0x9e, 0xdc, 0x89, 0x2a, 0x2b, 0x65, 0xae,
	0x8b, 0xbe, 0x34, 0x5f, 0x9c, 0x34, 0x3f, 0x54, 0x80, 0xd2, 0x3c, 0xac, 0xac, 0xbc, 0x8f, 0x60,
	0xed, 0x06, 0x3b, 0xb6, 0x6a, 0xff, 0x0e, 0x66, 0x9f, 0xeb, 0xe4, 0x34, 0xb5, 0xcc, 0x32, 0x3f,
	0x80, 0x7b, 0x87, 0xc8, 0xdf, 0x8e, 0xdb, 0xb9, 0x69, 0xdc, 0xbe, 0xc5, 0x1e, 0x1b, 0xb0, 0x3e,
	0xb1, 0x87, 0xcd, 0xec, 0x23, 0x58, 0xee, 0x27, 0x48, 0xd3, 0x3c, 0x3b, 0x48, 0x92, 0x62, 0xe7,
	0xfb, 0xd0, 0x50, 0xbc, 0xd3, 0x38, 0x45, 0xae, 0x2f, 0x59, 0x83, 0x8c, 0x05, 0xde, 0x2a, 0xb8,
	0x55, 0x13, 0xeb, 0xe8, 0x37, 0x07, 0xee, 0x3c, 0x7b, 0x83, 0x41, 0x2e, 0x19, 0x3f, 0xc9, 0xa4,
	0x50, 0x71, 0x71, 0x0c, 0x18, 0x0f, 0x7d, 0xd5, 0x7b, 0x85, 0x8e, 0xab, 0x4e, 0x9a, 0x46, 0xd6,
	0x57, 0x22, 0xf7, 0x5f, 0xd0, 0xb6, 0x10, 0x19, 0x8f, 0x30, 0x89, 0xd3, 0xe2, 0x1e, 0xb4, 0x8c,
	0xf8, 0x95, 0x95, 0xba, 0x1f, 0xc2, 0xba, 0x05, 0x66, 0x94, 0xcb, 0x58, 0xb1, 0x6e, 0x9a, 0xb9,
	0x49, 0x74, 0x9d, 0xac, 0x19, 0xf5, 0x69, 0xa1, 0xd5, 0x87, 0x14, 0xee, 0xe7, 0xe0, 0x71, 0xcc,
	0x18, 0x97, 0xb6, 0x4f, 0xf9, 0x34, 0x49, 0x58, 0x40, 0x75, 0xd6, 0xfc, 0x3c, 0x63, 0xa9, 0xcf,
	0xd8, 0x48, 0x27, 0xbb, 0x4e, 0xfe, 0x6a, 0x90, 0xaf, 0x34, 0xf0, 0x60, 0x8c, 0xfb, 0x32, 0x63,
	0xe9, 0x09, 0x1b, 0x79, 0xdf, 0xcf, 0x43, 0x9b, 0xe4, 0xe9, 0x2d, 0x29, 0xaa, 0xbf, 0x5f, 0x8a,
	0xdc, 0x75, 0x58, 0xd2, 0x63, 0x27, 0x0e, 0x75, 0x96, 0xe7, 0x49, 0x4d, 0x2d, 0x8f, 0x42, 0xf7,
	0x03, 0x68, 0xe0, 0x1b, 0x0c, 0x54, 0x65, 0x4e, 0x2d, 0xcb, 0x2a, 0xe7, 0xa4, 0xae, 0xa0, 0x9a,
	0xfd, 0x3d, 0x58, 0x10, 0x98, 0x86, 0xdd, 0xf9, 0xc9, 0x16, 0xf9, 0x85, 0x6a, 0xdc, 0xe6, 0x98,
	0xa7, 0xaa, 0x09, 0x13, 0x8d, 0x74, 0x37, 0xa0, 0xce, 0x31, 0xb8, 0xf4, 0x2f, 0xf0, 0xaa, 0xbb,
	0xa0, 0x73, 0xbe, 0xa4, 0xd6, 0x2f, 0xf0, 0xca, 0xdd, 0x02, 0x88, 0x85, 0xa1, 0x9e, 0x26, 0xdd,
	0x9a, 0xa6, 0xab, 0x11, 0x8b, 0x53, 0x23, 0x70, 0xff, 0x0b, 0x2b, 0xb1, 0xf0, 0x13, 0x2a, 0x64,
	0x81, 0xf1, 0x79, 0x9e, 0x76, 0x97, 0x34, 0xae, 0x13, 0x8b, 0x63, 0x2a, 0xa4, 0xc5, 0x92, 0x3c,
	0x75, 0x3f, 0x81, 0x2d, 0x21, 0x19, 0x47, 0x5f, 0x8f, 0x2e, 0xe1, 0xc7, 0xa9, 0xcf, 0x6d, 0x15,
	0xf9, 0x03, 0x16, 0x5e, 0x75, 0x1b, 0xda, 0x70, 0x43, 0x83, 0x9e, 0x69, 0xcc, 0x51, 0xd9, 0x8a,
	0x9e, 0xb2, 0xf0, 0xca, 0xfb, 0x75, 0x0e, 0x3a, 0xe3, 0x54, 0xd8, 0xbb, 0xb6, 0x07, 0x0b, 0x2a,
	0xde, 0x69, 0x43, 0x61, 0xf2, 0xc4, 0x0a, 0xa9, 0x5b, 0x78, 0x39, 0xea, 0xa7, 0xb6, 0x70, 0x89,
	0x99, 0xea, 0xc1, 0x82, 0x34, 0x44, 0xf1, 0xe9, 0x3e, 0x06, 0x18, 0x3f, 0x26, 0x74, 0xbd, 0xde,
	0xc8, 0x88, 0xaa, 0xed, 0xb2, 0xa1, 0x35, 0x82, 0x62, 0xe5, 0x3e, 0x81, 0xf6, 0x8d, 0xea, 0xd5,
	0x3c, 0xcf, 0x6a, 0x85, 0xad, 0xec, 0x5a, 0x31, 0xbb, 0x8f, 0xa1, 0x29, 0xf4, 0x4c, 0xd4, 0xc3,
	0x5e, 0x97, 0x42, 0x6b, 0xff, 0x5e, 0xd5, 0x54, 0xf3, 0xd9, 0xeb, 0xb3, 0x10, 0x09, 0x18, 0xa8,
	0xfa, 0x76, 0xf7, 0x60, 0xd5, 0x1a, 0x9a, 0xb7, 0xc2, 0x08, 0x85, 0xa0, 0x11, 0xea, 0x3c, 0x36,
	0x88, 0x6b, 0x74, 0x9a, 0xe7, 0x97, 0x46, 0xe3, 0xf5, 0x60, 0xc5, 0xde, 0xf0, 0x6b, 0xd5, 0x5e,
	0xa9, 0x51, 0xa7, 0x5a, 0xa3, 0xde, 0x3d, 0x58, 0xbd, 0x8e, 0xb7, 0x3d, 0xe1, 0x97, 0x39, 0x58,
	0x26, 0x18, 0x5c, 0x1a, 0xea, 0x6f, 0x73, 0xa3, 0x6e, 0x13, 0xc7, 0x34, 0xc4, 0xef, 0x2e, 0x59,
	0x2e, 0x74, 0x1d, 0xda, 0x86, 0x37, 0x96, 0xaa, 0x6a, 0x5c, 0x83, 0x5a, 0x38, 0xa2, 0x3e, 0xbb,
	0xb0, 0xcd, 0x62, 0x31, 0x1c, 0xd1, 0x93, 0x0b, 0xb7, 0x0f, 0xed, 0x20, 0x89, 0x31, 0x95, 0xbe,
	0xba, 0xba, 0x49, 0x2c, 0xaf, 0xec, 0x10, 0xd8, 0x9c, 0x7c, 0x1f, 0x1c, 0x5b, 0x04, 0x69, 0x19,
	0x93, 0x62, 0xad, 0x9c, 0xd8, 0xa9, 0x5e, 0x3a, 0x59, 0xbc, 0xdd, 0x89, 0x31, 0x29, 0x9d, 0x1c,
	0xc0, 0xb2, 0xe4, 0x34, 0x15, 0xba, 0xf1, 0x14, 0x13, 0xa5, 0x66, 0xa7, 0x9e, 0x79, 0xbd, 0xf6,
	0x8a, 0x97, 0x51, 0xef, 0x20, 0xbd, 0x22, 0x9d, 0x12, 0x5e, 0x0c, 0xa4, 0x2d, 0x00, 0x6e, 0xe8,
	0x52, 0x34, 0x2d, 0x69, 0x9a, 0x1a, 0x56, 0x72, 0x14, 0x7a, 0x3f, 0x3b, 0xe0, 0x56, 0x89, 0xb5,
	0x57, 0x60, 0x17, 0x6a, 0x26, 0x4a, 0x4d, 0x6c, 0x73, 0x7f, 0xbd, 0x1a, 0x74, 0xb5, 0xfe, 0x2d,
	0x4c, 0xa5, 0x22, 0x16, 0x7e, 0x88, 0xd4, 0x74, 0x9d, 0x3a, 0xa9, 0xc5, 0xe2, 0x10, 0x69, 0xe8,
	0x3e, 0x84, 0x65, 0xd5, 0x14, 0xd4, 0xd5, 0xe0, 0xd2, 0x1f, 0xc5, 0x01, 0x67, 0x42, 0xd3, 0x3d,
	0x4f, 0xda, 0x4a, 0x71, 0xa6, 0xe4, 0x2f, 0xb5, 0x78, 0xfa, 0x71, 0x17, 0xde, 0xe5, 0xb8, 0xde,
	0x05, 0xb4, 0x8e, 0x59, 0x14, 0xc5, 0x69, 0x54, 0x14, 0xc9, 0xdf, 0xa0, 0xc9, 0xb3, 0xc0, 0x4f,
	0x8c, 0xd4, 0x0e, 0x0f, 0xe0, 0x59, 0x60, 0x71, 0xee, 0x2a, 0x2c, 0x06, 0x09, 0x52, 0x6e, 0x03,
	0x37, 0x0b, 0xd7, 0x83, 0xbb, 0x43, 0x94, 0xc1, 0xb9, 0x5f, 0x54, 0x98, 0xea, 0x7f, 0xf3, 0xa4,
	0xa9, 0x85, 0x67, 0xa6, 0x5a, 0x29, 0x74, 0x8e, 0xe9, 0x00, 0x13, 0x0c, 0xcb, 0xfb, 0x3d, 0xbb,
	0x26, 0xdf, 0xab, 0x47, 0x78, 0x7d, 0x68, 0x97, 0xe7, 0x19, 0xb7, 0x27, 0xa5, 0x9f, 0xd6, 0x9e,
	0x6e, 0x46, 0x43, 0x34, 0xd2, 0xfb, 0x61, 0x0e, 0x1a, 0xaf, 0x38, 0x0d, 0x50, 0x37, 0xf4, 0x4d,
	0xa8, 0x87, 0x39, 0xd7, 0x23, 0x49, 0x87, 0xe8, 0x90, 0x72, 0xad, 0xb2, 0x95, 0x0b, 0x34, 0x67,
	0xce, 0x38, 0x1b, 0xc6, 0x09, 0x16, 0xbc, 0xb4, 0x73, 0x81, 0xca, 0xf1, 0xa9, 0x15, 0xbb, 0x3d,
	0x58, 0x51, 0xd8, 0x0b, 0xe4, 0x29, 0x26, 0x63, 0xb4, 0xb9, 0x4a, 0xca, 0xcd, 0x0b, 0xad, 0x29,
	0xf1, 0xfb, 0xb0, 0xa6, 0xf0, 0xf8, 0x46, 0xaa, 0x4b, 0x18, 0x8e, 0x2d, 0xcc, 0xe0, 0x55, 0xce,
	0x9e, 0x59, 0x5d, 0x69, 0xb3, 0x03, 0x1d, 0x65, 0x13, 0x65, 0xf9, 0x18, 0x6e, 0x86, 0x6c, 0x2b,
	0x17, 0xf8, 0x3c, 0xcb, 0x6f, 0x46, 0x23, 0xe8, 0x28, 0x4b, 0x70, 0x0c, 0xae, 0x95, 0xd1, 0x9c,
	0x69, 0x4d, 0x81, 0xf7, 0x0e, 0xa0, 0xa5, 0x28, 0xa9, 0x14, 0xca, 0x2e, 0x2c, 0x15, 0x35, 0xe7,
	0x4c, 0x66, 0xa7, 0xe4, 0x8f, 0x14, 0x28, 0x6f, 0x19, 0xda, 0xa5, 0x0b, 0x3b, 0x53, 0x46, 0xb0,
	0xc9, 0x78, 0x54, 0xb5, 0x0b, 0x63, 0x21, 0x79, 0x9e, 0xaa, 0x67, 0xc9, 0xd3, 0x3b, 0xe6, 0x4d,
	0xac, 0x6f, 0x8e, 0x38, 0x75, 0xbe, 0xfe, 0x38, 0x8a, 0xe5, 0x79, 0x3e, 0xe8, 0x05, 0x6c, 0x54,
	0xf9, 0xaf, 0x99, 0xf1, 0x19, 0xb1, 0xeb, 0x7f, 0x42, 0xbf, 0x3b, 0xce, 0xa0, 0xa6, 0x17, 0xff,
	0xfb, 0x23, 0x00, 0x00, 0xff, 0xff, 0x01, 0x02, 0x4d, 0x48, 0xfd, 0x0e, 0x00, 0x00,
}
